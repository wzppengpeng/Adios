// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: adios.proto

#ifndef PROTOBUF_adios_2eproto__INCLUDED
#define PROTOBUF_adios_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace adios_proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_adios_2eproto();
void protobuf_AssignDesc_adios_2eproto();
void protobuf_ShutdownFile_adios_2eproto();

class Task;
class Result;

enum MasterTaskType {
  MANAGENODE = 1,
  DELEVERY = 2,
  ASK = 3,
  PING = 4
};
bool MasterTaskType_IsValid(int value);
const MasterTaskType MasterTaskType_MIN = MANAGENODE;
const MasterTaskType MasterTaskType_MAX = PING;
const int MasterTaskType_ARRAYSIZE = MasterTaskType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MasterTaskType_descriptor();
inline const ::std::string& MasterTaskType_Name(MasterTaskType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MasterTaskType_descriptor(), value);
}
inline bool MasterTaskType_Parse(
    const ::std::string& name, MasterTaskType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MasterTaskType>(
    MasterTaskType_descriptor(), name, value);
}
enum SlaveMessageType {
  UPLOAD = 1,
  ANSWER = 2
};
bool SlaveMessageType_IsValid(int value);
const SlaveMessageType SlaveMessageType_MIN = UPLOAD;
const SlaveMessageType SlaveMessageType_MAX = ANSWER;
const int SlaveMessageType_ARRAYSIZE = SlaveMessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SlaveMessageType_descriptor();
inline const ::std::string& SlaveMessageType_Name(SlaveMessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SlaveMessageType_descriptor(), value);
}
inline bool SlaveMessageType_Parse(
    const ::std::string& name, SlaveMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SlaveMessageType>(
    SlaveMessageType_descriptor(), name, value);
}
// ===================================================================

class Task : public ::google::protobuf::Message {
 public:
  Task();
  virtual ~Task();

  Task(const Task& from);

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Task& default_instance();

  void Swap(Task* other);

  // implements Message ----------------------------------------------

  Task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string master_ip = 1;
  inline bool has_master_ip() const;
  inline void clear_master_ip();
  static const int kMasterIpFieldNumber = 1;
  inline const ::std::string& master_ip() const;
  inline void set_master_ip(const ::std::string& value);
  inline void set_master_ip(const char* value);
  inline void set_master_ip(const char* value, size_t size);
  inline ::std::string* mutable_master_ip();
  inline ::std::string* release_master_ip();
  inline void set_allocated_master_ip(::std::string* master_ip);

  // required int32 master_port = 2;
  inline bool has_master_port() const;
  inline void clear_master_port();
  static const int kMasterPortFieldNumber = 2;
  inline ::google::protobuf::int32 master_port() const;
  inline void set_master_port(::google::protobuf::int32 value);

  // required .adios_proto.MasterTaskType task_type = 3;
  inline bool has_task_type() const;
  inline void clear_task_type();
  static const int kTaskTypeFieldNumber = 3;
  inline ::adios_proto::MasterTaskType task_type() const;
  inline void set_task_type(::adios_proto::MasterTaskType value);

  // optional string node_name = 4;
  inline bool has_node_name() const;
  inline void clear_node_name();
  static const int kNodeNameFieldNumber = 4;
  inline const ::std::string& node_name() const;
  inline void set_node_name(const ::std::string& value);
  inline void set_node_name(const char* value);
  inline void set_node_name(const char* value, size_t size);
  inline ::std::string* mutable_node_name();
  inline ::std::string* release_node_name();
  inline void set_allocated_node_name(::std::string* node_name);

  // optional string task_queue_name = 5;
  inline bool has_task_queue_name() const;
  inline void clear_task_queue_name();
  static const int kTaskQueueNameFieldNumber = 5;
  inline const ::std::string& task_queue_name() const;
  inline void set_task_queue_name(const ::std::string& value);
  inline void set_task_queue_name(const char* value);
  inline void set_task_queue_name(const char* value, size_t size);
  inline ::std::string* mutable_task_queue_name();
  inline ::std::string* release_task_queue_name();
  inline void set_allocated_task_queue_name(::std::string* task_queue_name);

  // optional int64 task_id = 6;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 6;
  inline ::google::protobuf::int64 task_id() const;
  inline void set_task_id(::google::protobuf::int64 value);

  // optional string task_name = 7;
  inline bool has_task_name() const;
  inline void clear_task_name();
  static const int kTaskNameFieldNumber = 7;
  inline const ::std::string& task_name() const;
  inline void set_task_name(const ::std::string& value);
  inline void set_task_name(const char* value);
  inline void set_task_name(const char* value, size_t size);
  inline ::std::string* mutable_task_name();
  inline ::std::string* release_task_name();
  inline void set_allocated_task_name(::std::string* task_name);

  // optional int32 check_info = 8;
  inline bool has_check_info() const;
  inline void clear_check_info();
  static const int kCheckInfoFieldNumber = 8;
  inline ::google::protobuf::int32 check_info() const;
  inline void set_check_info(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:adios_proto.Task)
 private:
  inline void set_has_master_ip();
  inline void clear_has_master_ip();
  inline void set_has_master_port();
  inline void clear_has_master_port();
  inline void set_has_task_type();
  inline void clear_has_task_type();
  inline void set_has_node_name();
  inline void clear_has_node_name();
  inline void set_has_task_queue_name();
  inline void clear_has_task_queue_name();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_task_name();
  inline void clear_has_task_name();
  inline void set_has_check_info();
  inline void clear_has_check_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* master_ip_;
  ::google::protobuf::int32 master_port_;
  int task_type_;
  ::std::string* node_name_;
  ::std::string* task_queue_name_;
  ::google::protobuf::int64 task_id_;
  ::std::string* task_name_;
  ::google::protobuf::int32 check_info_;
  friend void  protobuf_AddDesc_adios_2eproto();
  friend void protobuf_AssignDesc_adios_2eproto();
  friend void protobuf_ShutdownFile_adios_2eproto();

  void InitAsDefaultInstance();
  static Task* default_instance_;
};
// -------------------------------------------------------------------

class Result : public ::google::protobuf::Message {
 public:
  Result();
  virtual ~Result();

  Result(const Result& from);

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Result& default_instance();

  void Swap(Result* other);

  // implements Message ----------------------------------------------

  Result* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Result& from);
  void MergeFrom(const Result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string slave_ip = 1;
  inline bool has_slave_ip() const;
  inline void clear_slave_ip();
  static const int kSlaveIpFieldNumber = 1;
  inline const ::std::string& slave_ip() const;
  inline void set_slave_ip(const ::std::string& value);
  inline void set_slave_ip(const char* value);
  inline void set_slave_ip(const char* value, size_t size);
  inline ::std::string* mutable_slave_ip();
  inline ::std::string* release_slave_ip();
  inline void set_allocated_slave_ip(::std::string* slave_ip);

  // required int32 slave_port = 2;
  inline bool has_slave_port() const;
  inline void clear_slave_port();
  static const int kSlavePortFieldNumber = 2;
  inline ::google::protobuf::int32 slave_port() const;
  inline void set_slave_port(::google::protobuf::int32 value);

  // required .adios_proto.SlaveMessageType answer_type = 3;
  inline bool has_answer_type() const;
  inline void clear_answer_type();
  static const int kAnswerTypeFieldNumber = 3;
  inline ::adios_proto::SlaveMessageType answer_type() const;
  inline void set_answer_type(::adios_proto::SlaveMessageType value);

  // optional string client_cmd = 4;
  inline bool has_client_cmd() const;
  inline void clear_client_cmd();
  static const int kClientCmdFieldNumber = 4;
  inline const ::std::string& client_cmd() const;
  inline void set_client_cmd(const ::std::string& value);
  inline void set_client_cmd(const char* value);
  inline void set_client_cmd(const char* value, size_t size);
  inline ::std::string* mutable_client_cmd();
  inline ::std::string* release_client_cmd();
  inline void set_allocated_client_cmd(::std::string* client_cmd);

  // optional int64 task_id = 5;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 5;
  inline ::google::protobuf::int64 task_id() const;
  inline void set_task_id(::google::protobuf::int64 value);

  // optional string task_result = 6;
  inline bool has_task_result() const;
  inline void clear_task_result();
  static const int kTaskResultFieldNumber = 6;
  inline const ::std::string& task_result() const;
  inline void set_task_result(const ::std::string& value);
  inline void set_task_result(const char* value);
  inline void set_task_result(const char* value, size_t size);
  inline ::std::string* mutable_task_result();
  inline ::std::string* release_task_result();
  inline void set_allocated_task_result(::std::string* task_result);

  // optional int32 answer_info = 7;
  inline bool has_answer_info() const;
  inline void clear_answer_info();
  static const int kAnswerInfoFieldNumber = 7;
  inline ::google::protobuf::int32 answer_info() const;
  inline void set_answer_info(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:adios_proto.Result)
 private:
  inline void set_has_slave_ip();
  inline void clear_has_slave_ip();
  inline void set_has_slave_port();
  inline void clear_has_slave_port();
  inline void set_has_answer_type();
  inline void clear_has_answer_type();
  inline void set_has_client_cmd();
  inline void clear_has_client_cmd();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_task_result();
  inline void clear_has_task_result();
  inline void set_has_answer_info();
  inline void clear_has_answer_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* slave_ip_;
  ::google::protobuf::int32 slave_port_;
  int answer_type_;
  ::std::string* client_cmd_;
  ::google::protobuf::int64 task_id_;
  ::std::string* task_result_;
  ::google::protobuf::int32 answer_info_;
  friend void  protobuf_AddDesc_adios_2eproto();
  friend void protobuf_AssignDesc_adios_2eproto();
  friend void protobuf_ShutdownFile_adios_2eproto();

  void InitAsDefaultInstance();
  static Result* default_instance_;
};
// ===================================================================


// ===================================================================

// Task

// required string master_ip = 1;
inline bool Task::has_master_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Task::set_has_master_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Task::clear_has_master_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Task::clear_master_ip() {
  if (master_ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_ip_->clear();
  }
  clear_has_master_ip();
}
inline const ::std::string& Task::master_ip() const {
  // @@protoc_insertion_point(field_get:adios_proto.Task.master_ip)
  return *master_ip_;
}
inline void Task::set_master_ip(const ::std::string& value) {
  set_has_master_ip();
  if (master_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_ip_ = new ::std::string;
  }
  master_ip_->assign(value);
  // @@protoc_insertion_point(field_set:adios_proto.Task.master_ip)
}
inline void Task::set_master_ip(const char* value) {
  set_has_master_ip();
  if (master_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_ip_ = new ::std::string;
  }
  master_ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:adios_proto.Task.master_ip)
}
inline void Task::set_master_ip(const char* value, size_t size) {
  set_has_master_ip();
  if (master_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_ip_ = new ::std::string;
  }
  master_ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:adios_proto.Task.master_ip)
}
inline ::std::string* Task::mutable_master_ip() {
  set_has_master_ip();
  if (master_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    master_ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:adios_proto.Task.master_ip)
  return master_ip_;
}
inline ::std::string* Task::release_master_ip() {
  clear_has_master_ip();
  if (master_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = master_ip_;
    master_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Task::set_allocated_master_ip(::std::string* master_ip) {
  if (master_ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete master_ip_;
  }
  if (master_ip) {
    set_has_master_ip();
    master_ip_ = master_ip;
  } else {
    clear_has_master_ip();
    master_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:adios_proto.Task.master_ip)
}

// required int32 master_port = 2;
inline bool Task::has_master_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Task::set_has_master_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Task::clear_has_master_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Task::clear_master_port() {
  master_port_ = 0;
  clear_has_master_port();
}
inline ::google::protobuf::int32 Task::master_port() const {
  // @@protoc_insertion_point(field_get:adios_proto.Task.master_port)
  return master_port_;
}
inline void Task::set_master_port(::google::protobuf::int32 value) {
  set_has_master_port();
  master_port_ = value;
  // @@protoc_insertion_point(field_set:adios_proto.Task.master_port)
}

// required .adios_proto.MasterTaskType task_type = 3;
inline bool Task::has_task_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Task::set_has_task_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Task::clear_has_task_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Task::clear_task_type() {
  task_type_ = 1;
  clear_has_task_type();
}
inline ::adios_proto::MasterTaskType Task::task_type() const {
  // @@protoc_insertion_point(field_get:adios_proto.Task.task_type)
  return static_cast< ::adios_proto::MasterTaskType >(task_type_);
}
inline void Task::set_task_type(::adios_proto::MasterTaskType value) {
  assert(::adios_proto::MasterTaskType_IsValid(value));
  set_has_task_type();
  task_type_ = value;
  // @@protoc_insertion_point(field_set:adios_proto.Task.task_type)
}

// optional string node_name = 4;
inline bool Task::has_node_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Task::set_has_node_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Task::clear_has_node_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Task::clear_node_name() {
  if (node_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_name_->clear();
  }
  clear_has_node_name();
}
inline const ::std::string& Task::node_name() const {
  // @@protoc_insertion_point(field_get:adios_proto.Task.node_name)
  return *node_name_;
}
inline void Task::set_node_name(const ::std::string& value) {
  set_has_node_name();
  if (node_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_name_ = new ::std::string;
  }
  node_name_->assign(value);
  // @@protoc_insertion_point(field_set:adios_proto.Task.node_name)
}
inline void Task::set_node_name(const char* value) {
  set_has_node_name();
  if (node_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_name_ = new ::std::string;
  }
  node_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:adios_proto.Task.node_name)
}
inline void Task::set_node_name(const char* value, size_t size) {
  set_has_node_name();
  if (node_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_name_ = new ::std::string;
  }
  node_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:adios_proto.Task.node_name)
}
inline ::std::string* Task::mutable_node_name() {
  set_has_node_name();
  if (node_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:adios_proto.Task.node_name)
  return node_name_;
}
inline ::std::string* Task::release_node_name() {
  clear_has_node_name();
  if (node_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_name_;
    node_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Task::set_allocated_node_name(::std::string* node_name) {
  if (node_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_name_;
  }
  if (node_name) {
    set_has_node_name();
    node_name_ = node_name;
  } else {
    clear_has_node_name();
    node_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:adios_proto.Task.node_name)
}

// optional string task_queue_name = 5;
inline bool Task::has_task_queue_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Task::set_has_task_queue_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Task::clear_has_task_queue_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Task::clear_task_queue_name() {
  if (task_queue_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_queue_name_->clear();
  }
  clear_has_task_queue_name();
}
inline const ::std::string& Task::task_queue_name() const {
  // @@protoc_insertion_point(field_get:adios_proto.Task.task_queue_name)
  return *task_queue_name_;
}
inline void Task::set_task_queue_name(const ::std::string& value) {
  set_has_task_queue_name();
  if (task_queue_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_queue_name_ = new ::std::string;
  }
  task_queue_name_->assign(value);
  // @@protoc_insertion_point(field_set:adios_proto.Task.task_queue_name)
}
inline void Task::set_task_queue_name(const char* value) {
  set_has_task_queue_name();
  if (task_queue_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_queue_name_ = new ::std::string;
  }
  task_queue_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:adios_proto.Task.task_queue_name)
}
inline void Task::set_task_queue_name(const char* value, size_t size) {
  set_has_task_queue_name();
  if (task_queue_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_queue_name_ = new ::std::string;
  }
  task_queue_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:adios_proto.Task.task_queue_name)
}
inline ::std::string* Task::mutable_task_queue_name() {
  set_has_task_queue_name();
  if (task_queue_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_queue_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:adios_proto.Task.task_queue_name)
  return task_queue_name_;
}
inline ::std::string* Task::release_task_queue_name() {
  clear_has_task_queue_name();
  if (task_queue_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = task_queue_name_;
    task_queue_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Task::set_allocated_task_queue_name(::std::string* task_queue_name) {
  if (task_queue_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete task_queue_name_;
  }
  if (task_queue_name) {
    set_has_task_queue_name();
    task_queue_name_ = task_queue_name;
  } else {
    clear_has_task_queue_name();
    task_queue_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:adios_proto.Task.task_queue_name)
}

// optional int64 task_id = 6;
inline bool Task::has_task_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Task::set_has_task_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Task::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Task::clear_task_id() {
  task_id_ = GOOGLE_LONGLONG(0);
  clear_has_task_id();
}
inline ::google::protobuf::int64 Task::task_id() const {
  // @@protoc_insertion_point(field_get:adios_proto.Task.task_id)
  return task_id_;
}
inline void Task::set_task_id(::google::protobuf::int64 value) {
  set_has_task_id();
  task_id_ = value;
  // @@protoc_insertion_point(field_set:adios_proto.Task.task_id)
}

// optional string task_name = 7;
inline bool Task::has_task_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Task::set_has_task_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Task::clear_has_task_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Task::clear_task_name() {
  if (task_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_name_->clear();
  }
  clear_has_task_name();
}
inline const ::std::string& Task::task_name() const {
  // @@protoc_insertion_point(field_get:adios_proto.Task.task_name)
  return *task_name_;
}
inline void Task::set_task_name(const ::std::string& value) {
  set_has_task_name();
  if (task_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_name_ = new ::std::string;
  }
  task_name_->assign(value);
  // @@protoc_insertion_point(field_set:adios_proto.Task.task_name)
}
inline void Task::set_task_name(const char* value) {
  set_has_task_name();
  if (task_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_name_ = new ::std::string;
  }
  task_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:adios_proto.Task.task_name)
}
inline void Task::set_task_name(const char* value, size_t size) {
  set_has_task_name();
  if (task_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_name_ = new ::std::string;
  }
  task_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:adios_proto.Task.task_name)
}
inline ::std::string* Task::mutable_task_name() {
  set_has_task_name();
  if (task_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:adios_proto.Task.task_name)
  return task_name_;
}
inline ::std::string* Task::release_task_name() {
  clear_has_task_name();
  if (task_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = task_name_;
    task_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Task::set_allocated_task_name(::std::string* task_name) {
  if (task_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete task_name_;
  }
  if (task_name) {
    set_has_task_name();
    task_name_ = task_name;
  } else {
    clear_has_task_name();
    task_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:adios_proto.Task.task_name)
}

// optional int32 check_info = 8;
inline bool Task::has_check_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Task::set_has_check_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Task::clear_has_check_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Task::clear_check_info() {
  check_info_ = 0;
  clear_has_check_info();
}
inline ::google::protobuf::int32 Task::check_info() const {
  // @@protoc_insertion_point(field_get:adios_proto.Task.check_info)
  return check_info_;
}
inline void Task::set_check_info(::google::protobuf::int32 value) {
  set_has_check_info();
  check_info_ = value;
  // @@protoc_insertion_point(field_set:adios_proto.Task.check_info)
}

// -------------------------------------------------------------------

// Result

// required string slave_ip = 1;
inline bool Result::has_slave_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Result::set_has_slave_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Result::clear_has_slave_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Result::clear_slave_ip() {
  if (slave_ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_ip_->clear();
  }
  clear_has_slave_ip();
}
inline const ::std::string& Result::slave_ip() const {
  // @@protoc_insertion_point(field_get:adios_proto.Result.slave_ip)
  return *slave_ip_;
}
inline void Result::set_slave_ip(const ::std::string& value) {
  set_has_slave_ip();
  if (slave_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_ip_ = new ::std::string;
  }
  slave_ip_->assign(value);
  // @@protoc_insertion_point(field_set:adios_proto.Result.slave_ip)
}
inline void Result::set_slave_ip(const char* value) {
  set_has_slave_ip();
  if (slave_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_ip_ = new ::std::string;
  }
  slave_ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:adios_proto.Result.slave_ip)
}
inline void Result::set_slave_ip(const char* value, size_t size) {
  set_has_slave_ip();
  if (slave_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_ip_ = new ::std::string;
  }
  slave_ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:adios_proto.Result.slave_ip)
}
inline ::std::string* Result::mutable_slave_ip() {
  set_has_slave_ip();
  if (slave_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slave_ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:adios_proto.Result.slave_ip)
  return slave_ip_;
}
inline ::std::string* Result::release_slave_ip() {
  clear_has_slave_ip();
  if (slave_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = slave_ip_;
    slave_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Result::set_allocated_slave_ip(::std::string* slave_ip) {
  if (slave_ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete slave_ip_;
  }
  if (slave_ip) {
    set_has_slave_ip();
    slave_ip_ = slave_ip;
  } else {
    clear_has_slave_ip();
    slave_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:adios_proto.Result.slave_ip)
}

// required int32 slave_port = 2;
inline bool Result::has_slave_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Result::set_has_slave_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Result::clear_has_slave_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Result::clear_slave_port() {
  slave_port_ = 0;
  clear_has_slave_port();
}
inline ::google::protobuf::int32 Result::slave_port() const {
  // @@protoc_insertion_point(field_get:adios_proto.Result.slave_port)
  return slave_port_;
}
inline void Result::set_slave_port(::google::protobuf::int32 value) {
  set_has_slave_port();
  slave_port_ = value;
  // @@protoc_insertion_point(field_set:adios_proto.Result.slave_port)
}

// required .adios_proto.SlaveMessageType answer_type = 3;
inline bool Result::has_answer_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Result::set_has_answer_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Result::clear_has_answer_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Result::clear_answer_type() {
  answer_type_ = 1;
  clear_has_answer_type();
}
inline ::adios_proto::SlaveMessageType Result::answer_type() const {
  // @@protoc_insertion_point(field_get:adios_proto.Result.answer_type)
  return static_cast< ::adios_proto::SlaveMessageType >(answer_type_);
}
inline void Result::set_answer_type(::adios_proto::SlaveMessageType value) {
  assert(::adios_proto::SlaveMessageType_IsValid(value));
  set_has_answer_type();
  answer_type_ = value;
  // @@protoc_insertion_point(field_set:adios_proto.Result.answer_type)
}

// optional string client_cmd = 4;
inline bool Result::has_client_cmd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Result::set_has_client_cmd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Result::clear_has_client_cmd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Result::clear_client_cmd() {
  if (client_cmd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_cmd_->clear();
  }
  clear_has_client_cmd();
}
inline const ::std::string& Result::client_cmd() const {
  // @@protoc_insertion_point(field_get:adios_proto.Result.client_cmd)
  return *client_cmd_;
}
inline void Result::set_client_cmd(const ::std::string& value) {
  set_has_client_cmd();
  if (client_cmd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_cmd_ = new ::std::string;
  }
  client_cmd_->assign(value);
  // @@protoc_insertion_point(field_set:adios_proto.Result.client_cmd)
}
inline void Result::set_client_cmd(const char* value) {
  set_has_client_cmd();
  if (client_cmd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_cmd_ = new ::std::string;
  }
  client_cmd_->assign(value);
  // @@protoc_insertion_point(field_set_char:adios_proto.Result.client_cmd)
}
inline void Result::set_client_cmd(const char* value, size_t size) {
  set_has_client_cmd();
  if (client_cmd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_cmd_ = new ::std::string;
  }
  client_cmd_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:adios_proto.Result.client_cmd)
}
inline ::std::string* Result::mutable_client_cmd() {
  set_has_client_cmd();
  if (client_cmd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_cmd_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:adios_proto.Result.client_cmd)
  return client_cmd_;
}
inline ::std::string* Result::release_client_cmd() {
  clear_has_client_cmd();
  if (client_cmd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_cmd_;
    client_cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Result::set_allocated_client_cmd(::std::string* client_cmd) {
  if (client_cmd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_cmd_;
  }
  if (client_cmd) {
    set_has_client_cmd();
    client_cmd_ = client_cmd;
  } else {
    clear_has_client_cmd();
    client_cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:adios_proto.Result.client_cmd)
}

// optional int64 task_id = 5;
inline bool Result::has_task_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Result::set_has_task_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Result::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Result::clear_task_id() {
  task_id_ = GOOGLE_LONGLONG(0);
  clear_has_task_id();
}
inline ::google::protobuf::int64 Result::task_id() const {
  // @@protoc_insertion_point(field_get:adios_proto.Result.task_id)
  return task_id_;
}
inline void Result::set_task_id(::google::protobuf::int64 value) {
  set_has_task_id();
  task_id_ = value;
  // @@protoc_insertion_point(field_set:adios_proto.Result.task_id)
}

// optional string task_result = 6;
inline bool Result::has_task_result() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Result::set_has_task_result() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Result::clear_has_task_result() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Result::clear_task_result() {
  if (task_result_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_result_->clear();
  }
  clear_has_task_result();
}
inline const ::std::string& Result::task_result() const {
  // @@protoc_insertion_point(field_get:adios_proto.Result.task_result)
  return *task_result_;
}
inline void Result::set_task_result(const ::std::string& value) {
  set_has_task_result();
  if (task_result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_result_ = new ::std::string;
  }
  task_result_->assign(value);
  // @@protoc_insertion_point(field_set:adios_proto.Result.task_result)
}
inline void Result::set_task_result(const char* value) {
  set_has_task_result();
  if (task_result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_result_ = new ::std::string;
  }
  task_result_->assign(value);
  // @@protoc_insertion_point(field_set_char:adios_proto.Result.task_result)
}
inline void Result::set_task_result(const char* value, size_t size) {
  set_has_task_result();
  if (task_result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_result_ = new ::std::string;
  }
  task_result_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:adios_proto.Result.task_result)
}
inline ::std::string* Result::mutable_task_result() {
  set_has_task_result();
  if (task_result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_result_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:adios_proto.Result.task_result)
  return task_result_;
}
inline ::std::string* Result::release_task_result() {
  clear_has_task_result();
  if (task_result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = task_result_;
    task_result_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Result::set_allocated_task_result(::std::string* task_result) {
  if (task_result_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete task_result_;
  }
  if (task_result) {
    set_has_task_result();
    task_result_ = task_result;
  } else {
    clear_has_task_result();
    task_result_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:adios_proto.Result.task_result)
}

// optional int32 answer_info = 7;
inline bool Result::has_answer_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Result::set_has_answer_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Result::clear_has_answer_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Result::clear_answer_info() {
  answer_info_ = 0;
  clear_has_answer_info();
}
inline ::google::protobuf::int32 Result::answer_info() const {
  // @@protoc_insertion_point(field_get:adios_proto.Result.answer_info)
  return answer_info_;
}
inline void Result::set_answer_info(::google::protobuf::int32 value) {
  set_has_answer_info();
  answer_info_ = value;
  // @@protoc_insertion_point(field_set:adios_proto.Result.answer_info)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace adios_proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::adios_proto::MasterTaskType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::adios_proto::MasterTaskType>() {
  return ::adios_proto::MasterTaskType_descriptor();
}
template <> struct is_proto_enum< ::adios_proto::SlaveMessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::adios_proto::SlaveMessageType>() {
  return ::adios_proto::SlaveMessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_adios_2eproto__INCLUDED
